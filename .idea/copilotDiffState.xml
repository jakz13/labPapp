<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ProyectoAerolineas/src/main/java/Logica/ManejadorCategoria.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ProyectoAerolineas/src/main/java/Logica/ManejadorCategoria.java" />
              <option name="originalContent" value="package Logica;&#10;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.TypedQuery;&#10;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;public class ManejadorCategoria {&#10;&#10;    private Map&lt;String, Categoria&gt; categorias;&#10;    private static ManejadorCategoria instancia;&#10;&#10;    private ManejadorCategoria() {&#10;        categorias = new HashMap&lt;&gt;();&#10;    }&#10;&#10;    public static ManejadorCategoria getInstance() {&#10;        if (instancia == null) {&#10;            instancia = new ManejadorCategoria();&#10;        }&#10;        return instancia;&#10;    }&#10;&#10;    // === Cargar todas las categorías desde la BD a memoria ===&#10;    public void cargarCategoriasDesdeBD(EntityManager em) {&#10;        TypedQuery&lt;Categoria&gt; query = em.createQuery(&quot;SELECT c FROM Categoria c&quot;, Categoria.class);&#10;        List&lt;Categoria&gt; categoriasPersistidas = query.getResultList();&#10;        for (Categoria c : categoriasPersistidas) {&#10;            categorias.put(c.getNombre(), c);&#10;        }&#10;    }&#10;&#10;    // === Agregar categoría en memoria y en BD ===&#10;    public void agregarCategoria(Categoria categoria, EntityManager em) {&#10;        categorias.put(categoria.getNombre(), categoria);&#10;&#10;        EntityTransaction tx = em.getTransaction();&#10;        try {&#10;            tx.begin();&#10;            em.persist(categoria);&#10;            tx.commit();&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) tx.rollback();&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // === Buscar categoría en memoria ===&#10;    public Categoria buscarCategorias(String nombre) {&#10;        return categorias.get(nombre);&#10;    }&#10;&#10;    // === Obtener todas las categorías ===&#10;    public Map&lt;String, Categoria&gt; getCategorias() {&#10;        return categorias;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package Logica;&#10;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.TypedQuery;&#10;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;public class ManejadorCategoria {&#10;&#10;    private Map&lt;String, Categoria&gt; categorias;&#10;    private static ManejadorCategoria instancia;&#10;&#10;    private ManejadorCategoria() {&#10;        categorias = new HashMap&lt;&gt;();&#10;    }&#10;&#10;    public static ManejadorCategoria getInstance() {&#10;        if (instancia == null) {&#10;            instancia = new ManejadorCategoria();&#10;        }&#10;        return instancia;&#10;    }&#10;&#10;    // === Cargar todas las categorías desde la BD a memoria ===&#10;    public void cargarCategoriasDesdeBD(EntityManager em) {&#10;        TypedQuery&lt;Categoria&gt; query = em.createQuery(&quot;SELECT c FROM Categoria c&quot;, Categoria.class);&#10;        List&lt;Categoria&gt; categoriasPersistidas = query.getResultList();&#10;        for (Categoria c : categoriasPersistidas) {&#10;            categorias.put(c.getNombre(), c);&#10;        }&#10;    }&#10;&#10;    // === Agregar categoría en memoria y en BD ===&#10;    public void agregarCategoria(Categoria categoria, EntityManager em) {&#10;        categorias.put(categoria.getNombre(), categoria);&#10;&#10;        EntityTransaction tx = em.getTransaction();&#10;        try {&#10;            tx.begin();&#10;            em.persist(categoria);&#10;            tx.commit();&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) tx.rollback();&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // === Buscar categoría en memoria ===&#10;    public Categoria buscarCategorias(String nombre) {&#10;        return categorias.get(nombre);&#10;    }&#10;&#10;    // === Obtener todas las categorías ===&#10;    public Map&lt;String, Categoria&gt; getCategorias() {&#10;        return categorias;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ProyectoAerolineas/src/main/java/logica/ManejadorVuelo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ProyectoAerolineas/src/main/java/logica/ManejadorVuelo.java" />
              <option name="originalContent" value="package logica;&#10;&#10;import DataTypes.DtVuelo;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.TypedQuery;&#10;import java.util.*;&#10;&#10;/**&#10; * Gestiona en memoria y en BD los vuelos del sistema.&#10; * Permite cargar, agregar, actualizar y eliminar vuelos, así como obtener DTs.&#10; */&#10;public final class ManejadorVuelo {&#10;&#10;    /** Mapa en memoria de vuelos indexado por nombre. */&#10;    private Map&lt;String, Vuelo&gt; vuelos;&#10;    /** Instancia singleton del manejador. */&#10;    public static ManejadorVuelo instancia = null;&#10;&#10;    private ManejadorVuelo() {&#10;        vuelos = new HashMap&lt;&gt;();&#10;    }&#10;&#10;    /** Obtiene la instancia singleton del manejador de vuelos. */&#10;    public static ManejadorVuelo getInstance() {&#10;        if (instancia == null) {&#10;            instancia = new ManejadorVuelo();&#10;        }&#10;        return instancia;&#10;    }&#10;&#10;    // =================== CRUD BD ===================&#10;    /** Carga los vuelos desde la base de datos */&#10;    public void cargarVuelosDesdeBD(EntityManager entManager) {&#10;        TypedQuery&lt;Vuelo&gt; query = entManager.createQuery(&quot;SELECT v FROM Vuelo v LEFT JOIN FETCH v.reservasList&quot;, Vuelo.class);&#10;        List&lt;Vuelo&gt; vuelosPersistidos = query.getResultList();&#10;        for (Vuelo v : vuelosPersistidos) {&#10;            // Sincronizar el Map con las reservas cargadas&#10;            v.getReservas(); // Esto sincroniza el Map&#10;            vuelos.put(v.getNombre(), v);&#10;        }&#10;    }&#10;&#10;    /** Método para uso interno (sin transacción) */&#10;    public void agregarVuelo(Vuelo vuelo, EntityManager entManager) {&#10;        entManager.persist(vuelo);&#10;        vuelos.put(vuelo.getNombre(), vuelo);&#10;    }&#10;&#10;    /** Método para uso externo (con transacción) */&#10;    public void agregarVueloConTransaccion(Vuelo vuelo, EntityManager entManager) {&#10;        EntityTransaction entTransaction = entManager.getTransaction();&#10;        try {&#10;            entTransaction.begin();&#10;            entManager.persist(vuelo);&#10;            vuelos.put(vuelo.getNombre(), vuelo);&#10;            entTransaction.commit();&#10;        } catch (Exception e) {&#10;            if (entTransaction.isActive()) entTransaction.rollback();&#10;            throw new IllegalStateException(&quot;Error al agregar el vuelo: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /** Método para uso interno (sin transacción) - usado por registrarReservaVuelo */&#10;    public void actualizarVuelo(Vuelo vuelo, EntityManager entManager) {&#10;        entManager.merge(vuelo);&#10;    }&#10;&#10;    /** Método para uso externo (con transacción) */&#10;    public void actualizarVueloConTransaccion(Vuelo vuelo, EntityManager entManager) {&#10;        EntityTransaction entTransaction = entManager.getTransaction();&#10;        try {&#10;            entTransaction.begin();&#10;            entManager.merge(vuelo);&#10;            entTransaction.commit();&#10;        } catch (Exception e) {&#10;            if (entTransaction.isActive()) entTransaction.rollback();&#10;            throw new IllegalStateException(&quot;Error al actualizar el vuelo: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /** Verifica si un vuelo tiene reserva de un cliente */&#10;    public boolean tieneReservaDeCliente(String nicknameCliente, Vuelo vuelo) {&#10;        return vuelo.getReservas().containsKey(nicknameCliente);&#10;    }&#10;&#10;    /** Obtiene un vuelo por su nombre */&#10;    public Vuelo getVuelo(String nombre) {&#10;        return vuelos.get(nombre);&#10;    }&#10;&#10;    /** Obtiene la lista de vuelos */&#10;    public List&lt;Vuelo&gt; getVuelos() {&#10;        return new ArrayList&lt;&gt;(vuelos.values());&#10;    }&#10;&#10;    /** Obtiene la lista de DTs de vuelos */&#10;    public List&lt;DtVuelo&gt; getDtVuelos() {&#10;        List&lt;DtVuelo&gt; dtVuelos = new ArrayList&lt;&gt;();&#10;        for (Vuelo vuelo : vuelos.values()) {&#10;            dtVuelos.add(vuelo.getDtVuelo());&#10;        }&#10;        return dtVuelos;&#10;    }&#10;&#10;    /** Método para obtener vuelos por aerolínea */&#10;    public List&lt;Vuelo&gt; getVuelosPorAerolinea(String nombreAerolinea) {&#10;        List&lt;Vuelo&gt; vuelosAerolinea = new ArrayList&lt;&gt;();&#10;        for (Vuelo vuelo : vuelos.values()) {&#10;            if (vuelo.getNombreAerolinea().equals(nombreAerolinea)) {&#10;                vuelosAerolinea.add(vuelo);&#10;            }&#10;        }&#10;        return vuelosAerolinea;&#10;    }&#10;&#10;    /** Método para obtener vuelos por ruta */&#10;    public List&lt;Vuelo&gt; getVuelosPorRuta(String nombreRuta) {&#10;        List&lt;Vuelo&gt; vuelosRuta = new ArrayList&lt;&gt;();&#10;        for (Vuelo vuelo : vuelos.values()) {&#10;            if (vuelo.getRutaVuelo() != null &amp;&amp;&#10;                    vuelo.getRutaVuelo().getNombre().equals(nombreRuta)) {&#10;                vuelosRuta.add(vuelo);&#10;            }&#10;        }&#10;        return vuelosRuta;&#10;    }&#10;&#10;    /** Método para verificar si existe un vuelo */&#10;    public boolean existeVuelo(String nombreVuelo) {&#10;        return vuelos.containsKey(nombreVuelo);&#10;    }&#10;&#10;    /** Método para eliminar vuelo (con transacción) */&#10;    public void eliminarVuelo(String nombreVuelo, EntityManager entManager) {&#10;        EntityTransaction entTransaction = entManager.getTransaction();&#10;        try {&#10;            entTransaction.begin();&#10;            Vuelo vuelo = vuelos.get(nombreVuelo);&#10;            if (vuelo != null) {&#10;                entManager.remove(vuelo);&#10;                vuelos.remove(nombreVuelo);&#10;            }&#10;            entTransaction.commit();&#10;        } catch (Exception e) {&#10;            if (entTransaction.isActive()) entTransaction.rollback();&#10;            throw new IllegalStateException(&quot;Error al eliminar el vuelo: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /** Método para limpiar cache en memoria (útil para testing) */&#10;    public void limpiarCache() {&#10;        vuelos.clear();&#10;    }&#10;}" />
              <option name="updatedContent" value="package logica;&#10;&#10;import DataTypes.DtVuelo;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.TypedQuery;&#10;import java.util.*;&#10;&#10;/**&#10; * Gestiona en memoria y en BD los vuelos del sistema.&#10; * Permite cargar, agregar, actualizar y eliminar vuelos, así como obtener DTs.&#10; */&#10;public final class ManejadorVuelo {&#10;&#10;    /** Mapa en memoria de vuelos indexado por nombre. */&#10;    private Map&lt;String, Vuelo&gt; vuelos;&#10;    /** Instancia singleton del manejador. */&#10;    public static ManejadorVuelo instancia = null;&#10;&#10;    private ManejadorVuelo() {&#10;        vuelos = new HashMap&lt;&gt;();&#10;    }&#10;&#10;    /** Obtiene la instancia singleton del manejador de vuelos. */&#10;    public static ManejadorVuelo getInstance() {&#10;        if (instancia == null) {&#10;            instancia = new ManejadorVuelo();&#10;        }&#10;        return instancia;&#10;    }&#10;&#10;    // =================== CRUD BD ===================&#10;    /** Carga los vuelos desde la base de datos */&#10;    public void cargarVuelosDesdeBD(EntityManager entManager) {&#10;        TypedQuery&lt;Vuelo&gt; query = entManager.createQuery(&quot;SELECT v FROM Vuelo v LEFT JOIN FETCH v.reservasList&quot;, Vuelo.class);&#10;        List&lt;Vuelo&gt; vuelosPersistidos = query.getResultList();&#10;        for (Vuelo v : vuelosPersistidos) {&#10;            // Sincronizar el Map con las reservas cargadas&#10;            v.getReservas(); // Esto sincroniza el Map&#10;            vuelos.put(v.getNombre(), v);&#10;        }&#10;    }&#10;&#10;    /** Método para uso interno (sin transacción) */&#10;    public void agregarVuelo(Vuelo vuelo, EntityManager entManager) {&#10;        entManager.persist(vuelo);&#10;        vuelos.put(vuelo.getNombre(), vuelo);&#10;    }&#10;&#10;    /** Método para uso externo (con transacción) */&#10;    public void agregarVueloConTransaccion(Vuelo vuelo, EntityManager entManager) {&#10;        EntityTransaction entTransaction = entManager.getTransaction();&#10;        try {&#10;            entTransaction.begin();&#10;            entManager.persist(vuelo);&#10;            vuelos.put(vuelo.getNombre(), vuelo);&#10;            entTransaction.commit();&#10;        } catch (Exception e) {&#10;            if (entTransaction.isActive()) entTransaction.rollback();&#10;            throw new IllegalStateException(&quot;Error al agregar el vuelo: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /** Método para uso interno (sin transacción) - usado por registrarReservaVuelo */&#10;    public void actualizarVuelo(Vuelo vuelo, EntityManager entManager) {&#10;        entManager.merge(vuelo);&#10;    }&#10;&#10;    /** Método para uso externo (con transacción) */&#10;    public void actualizarVueloConTransaccion(Vuelo vuelo, EntityManager entManager) {&#10;        EntityTransaction entTransaction = entManager.getTransaction();&#10;        try {&#10;            entTransaction.begin();&#10;            entManager.merge(vuelo);&#10;            entTransaction.commit();&#10;        } catch (Exception e) {&#10;            if (entTransaction.isActive()) entTransaction.rollback();&#10;            throw new IllegalStateException(&quot;Error al actualizar el vuelo: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /** Verifica si un vuelo tiene reserva de un cliente */&#10;    public boolean tieneReservaDeCliente(String nicknameCliente, Vuelo vuelo) {&#10;        return vuelo.getReservas().containsKey(nicknameCliente);&#10;    }&#10;&#10;    /** Obtiene un vuelo por su nombre */&#10;    public Vuelo getVuelo(String nombre) {&#10;        return vuelos.get(nombre);&#10;    }&#10;&#10;    /** Obtiene la lista de vuelos */&#10;    public List&lt;Vuelo&gt; getVuelos() {&#10;        return new ArrayList&lt;&gt;(vuelos.values());&#10;    }&#10;&#10;    /** Obtiene la lista de DTs de vuelos */&#10;    public List&lt;DtVuelo&gt; getDtVuelos() {&#10;        List&lt;DtVuelo&gt; dtVuelos = new ArrayList&lt;&gt;();&#10;        for (Vuelo vuelo : vuelos.values()) {&#10;            dtVuelos.add(vuelo.getDtVuelo());&#10;        }&#10;        return dtVuelos;&#10;    }&#10;&#10;    /** Método para obtener vuelos por aerolínea */&#10;    public List&lt;Vuelo&gt; getVuelosPorAerolinea(String nombreAerolinea) {&#10;        List&lt;Vuelo&gt; vuelosAerolinea = new ArrayList&lt;&gt;();&#10;        for (Vuelo vuelo : vuelos.values()) {&#10;            if (vuelo.getNombreAerolinea().equals(nombreAerolinea)) {&#10;                vuelosAerolinea.add(vuelo);&#10;            }&#10;        }&#10;        return vuelosAerolinea;&#10;    }&#10;&#10;    /** Método para obtener vuelos por ruta */&#10;    public List&lt;Vuelo&gt; getVuelosPorRuta(String nombreRuta) {&#10;        List&lt;Vuelo&gt; vuelosRuta = new ArrayList&lt;&gt;();&#10;        for (Vuelo vuelo : vuelos.values()) {&#10;            if (vuelo.getRutaVuelo() != null &amp;&amp;&#10;                    vuelo.getRutaVuelo().getNombre().equals(nombreRuta)) {&#10;                vuelosRuta.add(vuelo);&#10;            }&#10;        }&#10;        return vuelosRuta;&#10;    }&#10;&#10;    /** Método para verificar si existe un vuelo */&#10;    public boolean existeVuelo(String nombreVuelo) {&#10;        return vuelos.containsKey(nombreVuelo);&#10;    }&#10;&#10;    /** Método para eliminar vuelo (con transacción) */&#10;    public void eliminarVuelo(String nombreVuelo, EntityManager entManager) {&#10;        EntityTransaction entTransaction = entManager.getTransaction();&#10;        try {&#10;            entTransaction.begin();&#10;            Vuelo vuelo = vuelos.get(nombreVuelo);&#10;            if (vuelo != null) {&#10;                entManager.remove(vuelo);&#10;                vuelos.remove(nombreVuelo);&#10;            }&#10;            entTransaction.commit();&#10;        } catch (Exception e) {&#10;            if (entTransaction.isActive()) entTransaction.rollback();&#10;            throw new IllegalStateException(&quot;Error al eliminar el vuelo: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /** Método para limpiar cache en memoria (útil para testing) */&#10;    public void limpiarCache() {&#10;        vuelos.clear();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ProyectoAerolineas/src/main/java/logica/TipoAsiento.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ProyectoAerolineas/src/main/java/logica/TipoAsiento.java" />
              <option name="originalContent" value="package logica;&#10;&#10;/**&#10; * Enum con los tipos de asiento disponibles en los vuelos.&#10; */&#10;public enum TipoAsiento {&#10;    TURISTA,&#10;    EJECUTIVO&#10;}&#10;" />
              <option name="updatedContent" value="package logica;&#13;&#10;&#13;&#10;/**&#13;&#10; * Enum con los tipos de asiento disponibles en los vuelos.&#13;&#10; */&#13;&#10;public enum TipoAsiento {&#13;&#10;    TURISTA,&#13;&#10;    EJECUTIVO&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ProyectoAerolineas/src/main/java/logica/TipoDoc.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ProyectoAerolineas/src/main/java/logica/TipoDoc.java" />
              <option name="originalContent" value="package logica;&#10;&#10;/**&#10; * Enum que representa los tipos de documento soportados en el sistema.&#10; */&#10;public enum TipoDoc {&#10;        CEDULAIDENTIDAD,&#10;        PASAPORTE;&#10;&#10;    /**&#10;     * Indica si el valor del enum es considerado vacío. Este método está&#10;     * incluido por conveniencia, aunque una instancia de enum nunca es null.&#10;     * @return siempre false para valores válidos&#10;     */&#10;    public boolean isEmpty() {&#10;        if (this == null) {&#10;            return true;&#10;        }&#10;        else {&#10;            return false;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package logica;&#13;&#10;&#13;&#10;/**&#13;&#10; * Enum que representa los tipos de documento soportados en el sistema.&#13;&#10; */&#13;&#10;public enum TipoDoc {&#13;&#10;        CEDULAIDENTIDAD,&#13;&#10;        PASAPORTE;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Indica si el valor del enum es considerado vacío. Este método está&#13;&#10;     * incluido por conveniencia, aunque una instancia de enum nunca es null.&#13;&#10;     * @return siempre false para valores válidos&#13;&#10;     */&#13;&#10;    public boolean isEmpty() {&#13;&#10;        if (this == null) {&#13;&#10;            return true;&#13;&#10;        }&#13;&#10;        else {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>